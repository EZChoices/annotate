(function (global) {
  "use strict";

  // --- Storage keys & in-memory fallback ------------------------------------
  const RECORDS_KEY = "ea_stage2_irr_records";
  const SUMMARY_KEY = "ea_stage2_irr_summary";
  const memoryStore = { records: null, summary: null }; // records stored normalized

  // --- Environment guards ----------------------------------------------------
  function hasLocalStorage() {
    try {
      return typeof localStorage !== "undefined" && localStorage !== null;
    } catch {
      return false;
    }
  }

  // --- Utils -----------------------------------------------------------------
  function clamp01(value) {
    if (!Number.isFinite(value)) return 0;
    if (value < 0) return 0;
    if (value > 1) return 1;
    return value;
  }

  function clone(obj) {
    return obj ? JSON.parse(JSON.stringify(obj)) : obj;
  }

  function average(values) {
    const finite = (values || []).filter((v) => Number.isFinite(v));
    if (!finite.length) return null;
    const sum = finite.reduce((acc, v) => acc + v, 0);
    return sum / finite.length;
  }

  function buildPairs(list) {
    const pairs = [];
    for (let i = 0; i < list.length; i += 1) {
      for (let j = i + 1; j < list.length; j += 1) {
        pairs.push([list[i], list[j]]);
      }
    }
    return pairs;
  }

  function toFinite(value) {
    if (value == null) return null;
    const num = typeof value === "string" ? parseFloat(value) : Number(value);
    return Number.isFinite(num) ? num : null;
  }

  // Normalize arbitrary metric shapes to a canonical metric object
  // Canonical keys: codeSwitchF1 [0..1], diarizationMae (sec), cueDeltaSec (sec), translationCompleteness [0..1]
  function sanitizeMetrics(metrics) {
    const src = metrics && typeof metrics === "object" ? metrics : {};
    const codeSwitchF1 =
      toFinite(src.codeSwitchF1 ?? src.codeswitch_f1 ?? src.code_switch_f1);
    const diarizationMae =
      toFinite(src.diarizationMae ?? src.diarization_mae ?? src.diarMae);
    const cueDeltaSec = toFinite(
      src.cueDeltaSec ?? src.cueDelta ?? src.cue_delta ?? src.cue_diff_sec ?? src.cueDeltaSec
    );
    const translationCompleteness = toFinite(
      src.translationCompleteness ??
        src.translation_completeness ??
        src.translationCompletenessRatio
    );
    return {
      ...(Number.isFinite(codeSwitchF1) ? { codeSwitchF1 } : {}),
      ...(Number.isFinite(diarizationMae) ? { diarizationMae } : {}),
      ...(Number.isFinite(cueDeltaSec) ? { cueDeltaSec } : {}),
      ...(Number.isFinite(translationCompleteness)
        ? { translationCompleteness }
        : {}),
    };
  }

  // --- Records model (normalized) -------------------------------------------
  // We store records as:
  // { clips: { [clipId]: { clipId, annotations: { [annotatorId]: { ...metrics, recordedAt } } } } }
  let cache = null;

  function normalizeRecords(records) {
    if (!records) {
      return { clips: {} };
    }
    // Legacy array form: [{clipId, annotatorId, metrics}, ...] or entries with .annotations map/array
    if (Array.isArray(records)) {
      const clips = {};
      records.forEach((entry) => {
        if (!entry || !entry.clipId) return;
        const clipId = entry.clipId;
        if (!clips[clipId]) clips[clipId] = { clipId, annotations: {} };

        if (entry.annotatorId) {
          clips[clipId].annotations[entry.annotatorId] =
            sanitizeMetrics(entry.metrics) || {};
        } else {
          // If it's an entry with a nested annotations list/map
          const items = Array.isArray(entry.annotations)
            ? entry.annotations
            : Object.entries(entry.annotations || {}).map(
                ([annotatorId, metrics]) => ({
                  annotatorId,
                  metrics,
                })
              );
          items.forEach((item) => {
            if (!item || !item.annotatorId) return;
            clips[clipId].annotations[item.annotatorId] =
              sanitizeMetrics(item.metrics) || {};
          });
        }
      });
      return { clips };
    }
    // Already structured
    if (records.clips && typeof records.clips === "object") {
      const clips = {};
      Object.keys(records.clips).forEach((clipId) => {
        const clip = records.clips[clipId];
        if (!clip) return;
        const annotations = Array.isArray(clip.annotations)
          ? clip.annotations.reduce((map, ann) => {
              if (!ann || !ann.annotatorId) return map;
              map[ann.annotatorId] = sanitizeMetrics(ann.metrics) || {};
              return map;
            }, {})
          : Object.keys(clip.annotations || {}).reduce((map, annotatorId) => {
              map[annotatorId] = sanitizeMetrics(
                clip.annotations[annotatorId]
              ) || {};
              return map;
            }, {});
        clips[clipId] = { clipId, annotations };
      });
      return { clips };
    }
    return { clips: {} };
  }

  function loadRecordsFromStorage() {
    if (!hasLocalStorage()) return null;
    try {
      const raw = localStorage.getItem(RECORDS_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (err) {
      console.warn("IRR: failed to load records from storage", err);
      return null;
    }
  }

  function ensureRecords() {
    if (cache) return cache;
    const stored = loadRecordsFromStorage();
    cache = normalizeRecords(stored || memoryStore.records);
    if (!cache || !cache.clips) cache = { clips: {} };
    return cache;
  }

  function persistRecords(records) {
    cache = normalizeRecords(records);
    memoryStore.records = clone(cache);
    if (hasLocalStorage()) {
      try {
        localStorage.setItem(RECORDS_KEY, JSON.stringify(cache));
      } catch (err) {
        console.warn("IRR: failed to persist records", err);
      }
    }
    // Also attach to global for debugging/legacy access
    global.__IRR_RECORDS__ = clone(cache);
    return cache;
  }

  // --- Public API: record annotation ----------------------------------------
  function recordAnnotation(annotatorId, clipId, metrics) {
    if (!clipId) return null;
    const id = annotatorId || "anonymous";
    const normalized = sanitizeMetrics(metrics);
    const records = ensureRecords();
    const clip = records.clips[clipId] || { clipId, annotations: {} };
    clip.annotations[id] = Object.assign({}, normalized, {
      recordedAt: Date.now(),
    });
    records.clips[clipId] = clip;
    persistRecords(records);
    const summary = computeIRRSummary(records);
    saveIRRSummary({ summary });
    return { annotatorId: id, clipId, metrics: normalized };
  }

  // --- IRR math --------------------------------------------------------------
  const DEFAULT_MAX_DIAR_SEC = 5; // seconds
  const DEFAULT_MAX_CUE_DELTA = 4; // seconds

  // Pairwise agreement proxy across metrics; returns alphas per metric and overall
  function computeAlpha(annotationsList, options) {
    const opts = options || {};
    const maxDiar = Number.isFinite(opts.maxDiarizationSeconds)
      ? opts.maxDiarizationSeconds
      : DEFAULT_MAX_DIAR_SEC;
    const maxCueDelta = Number.isFinite(opts.maxCueDeltaSec)
      ? opts.maxCueDeltaSec
      : DEFAULT_MAX_CUE_DELTA;

    // Accept either [{annotatorId, metrics}, ...] OR map { annotatorId: metrics }
    const annotations = Array.isArray(annotationsList)
      ? annotationsList.filter((e) => e && e.metrics)
      : Object.keys(annotationsList || {}).map((key) => ({
          annotatorId: key,
          metrics: annotationsList[key],
        }));

    const cleaned = annotations.filter((e) => e && e.metrics);
    if (cleaned.length < 2) {
      return {
        codeSwitchAlpha: null,
        diarizationAlpha: null,
        cueAlpha: null,
        translationAlpha: null,
        overallAlpha: null,
      };
    }

    const pairs = buildPairs(cleaned);

    const codeSwitchScores = [];
    const diarizationScores = [];
    const cueScores = [];
    const translationScores = [];

    pairs.forEach(([a, b]) => {
      const ma = a.metrics || {};
      const mb = b.metrics || {};

      // Code-switch F1: closer means better; use midpoint then clamp
      const f1a = Number(ma.codeSwitchF1);
      const f1b = Number(mb.codeSwitchF1);
      if (Number.isFinite(f1a) && Number.isFinite(f1b)) {
        codeSwitchScores.push(clamp01((f1a + f1b) / 2));
      }

      // Diarization MAE (sec): lower is better; invert by range
      const maeA = Number(ma.diarizationMae);
      const maeB = Number(mb.diarizationMae);
      if (Number.isFinite(maeA) && Number.isFinite(maeB)) {
        const invA = clamp01(1 - Math.min(Math.abs(maeA), maxDiar) / maxDiar);
        const invB = clamp01(1 - Math.min(Math.abs(maeB), maxDiar) / maxDiar);
        diarizationScores.push((invA + invB) / 2);
      }

      // Cue delta (sec): lower is better; invert by range
      const cueA = Number(
        ma.cueDeltaSec ?? ma.cueDelta ?? ma.cue_delta ?? ma.cue_diff_sec
      );
      const cueB = Number(
        mb.cueDeltaSec ?? mb.cueDelta ?? mb.cue_delta ?? mb.cue_diff_sec
      );
      if (Number.isFinite(cueA) && Number.isFinite(cueB)) {
        const scoreA = clamp01(1 - Math.min(Math.abs(cueA), maxCueDelta) / maxCueDelta);
        const scoreB = clamp01(1 - Math.min(Math.abs(cueB), maxCueDelta) / maxCueDelta);
        cueScores.push((scoreA + scoreB) / 2);
      }

      // Translation completeness [0..1]: closer is better; 1 - abs diff
      const transA = Number(ma.translationCompleteness);
      const transB = Number(mb.translationCompleteness);
      if (Number.isFinite(transA) && Number.isFinite(transB)) {
        const diff = Math.abs(transA - transB);
        translationScores.push(clamp01(1 - diff));
      }
    });

    const codeSwitchAlpha = average(codeSwitchScores);
    const diarizationAlpha = average(diarizationScores);
    const cueAlpha = average(cueScores);
    const translationAlpha = average(translationScores);

    const components = [codeSwitchAlpha, diarizationAlpha, cueAlpha, translationAlpha].filter(
      (v) => Number.isFinite(v)
    );
    const overallAlpha = components.length ? average(components) : null;

    return {
      codeSwitchAlpha: codeSwitchAlpha != null ? clamp01(codeSwitchAlpha) : null,
      diarizationAlpha: diarizationAlpha != null ? clamp01(diarizationAlpha) : null,
      cueAlpha: cueAlpha != null ? clamp01(cueAlpha) : null,
      translationAlpha: translationAlpha != null ? clamp01(translationAlpha) : null,
      overallAlpha: overallAlpha != null ? clamp01(overallAlpha) : null,
    };
  }

  function computeIRRSummary(recordsInput) {
    const data = normalizeRecords(recordsInput != null ? recordsInput : ensureRecords());
    const clips = data.clips || {};
    const entries = Object.keys(clips)
      .map((clipId) => clips[clipId])
      .filter(Boolean);

    let clipCount = 0;
    const codeSwitchValues = [];
    const diarizationValues = [];
    const cueValues = [];
    const translationValues = [];

    entries.forEach((clip) => {
      const annotations = (clip && clip.annotations) || {};
      const annList = Object.keys(annotations).map((annotatorId) => ({
        annotatorId,
        metrics: annotations[annotatorId],
      }));
      if (annList.length < 2) return;
      clipCount += 1;
      const alpha = computeAlpha(annList);
      if (alpha.codeSwitchAlpha != null) codeSwitchValues.push(alpha.codeSwitchAlpha);
      if (alpha.diarizationAlpha != null) diarizationValues.push(alpha.diarizationAlpha);
      if (alpha.cueAlpha != null) cueValues.push(alpha.cueAlpha);
      if (alpha.translationAlpha != null) translationValues.push(alpha.translationAlpha);
    });

    const codeSwitchAlpha =
      codeSwitchValues.length ? average(codeSwitchValues) : null;
    const diarizationAlpha =
      diarizationValues.length ? average(diarizationValues) : null;
    const cueAlpha = cueValues.length ? average(cueValues) : null;
    const translationAlpha =
      translationValues.length ? average(translationValues) : null;

    const components = [codeSwitchAlpha, diarizationAlpha, cueAlpha, translationAlpha].filter(
      (v) => Number.isFinite(v)
    );
    const overallAlpha = components.length ? average(components) : null;

    return {
      generatedAt: new Date().toISOString(),
      clipsEvaluated: clipCount,
      codeSwitchAlpha: codeSwitchAlpha != null ? clamp01(codeSwitchAlpha) : null,
      diarizationAlpha: diarizationAlpha != null ? clamp01(diarizationAlpha) : null,
      cueAlpha: cueAlpha != null ? clamp01(cueAlpha) : null,
      translationAlpha: translationAlpha != null ? clamp01(translationAlpha) : null,
      overallAlpha: overallAlpha != null ? clamp01(overallAlpha) : null,
    };
  }

  function saveIRRSummary(options) {
    const opts = options || {};
    const summary =
      opts.summary || computeIRRSummary(opts.records != null ? opts.records : undefined);

    // Persist to localStorage
    if (hasLocalStorage()) {
      try {
        localStorage.setItem(SUMMARY_KEY, JSON.stringify(summary));
      } catch (err) {
        console.warn("IRR: failed to persist summary", err);
      }
    }

    // Persist to memory & global
    memoryStore.summary = clone(summary);
    global.__IRR_SUMMARY__ = clone(summary);

    // Optional: write to disk if running in Node and path provided
    if (opts.path) {
      try {
        const fs = require("fs");
        const path = require("path");
        const targetPath = path.resolve(opts.path);
        fs.writeFileSync(targetPath, JSON.stringify(summary, null, 2));
      } catch (err) {
        console.warn("IRR: unable to write summary to disk", err);
      }
    }
    return summary;
  }

  function formatCoverageLabel(value) {
    if (!value || value === 'unknown') return 'Unknown';
    const text = String(value)
      .trim()
      .replace(/[_\s]+/g, ' ')
      .toLowerCase();
    return text.replace(/\b([a-z])/g, (match, letter) => letter.toUpperCase());
  }

  function ensureCoverageContainer() {
    if (typeof document === 'undefined') return null;
    let container = document.getElementById('coverageSummary');
    if (!container) {
      container = document.createElement('section');
      container.id = 'coverageSummary';
      container.className = 'coverage-summary';
      if (document.body) {
        document.body.insertBefore(container, document.body.firstChild || null);
      }
    }
    return container;
  }

  function injectCoverageStyles() {
    if (typeof document === 'undefined') return;
    if (document.getElementById('coverageSummaryStyles')) return;
    const style = document.createElement('style');
    style.id = 'coverageSummaryStyles';
    style.textContent = `
      .coverage-summary { max-width: 920px; margin: 1.5rem auto; padding: 1rem; background: var(--card, #fff); border-radius: 12px; border: 1px solid var(--border, #dcdcdc); box-shadow: 0 4px 24px rgba(0, 0, 0, 0.04); }
      .coverage-summary h2 { margin: 0 0 .75rem 0; font-size: 1.25rem; }
      .coverage-summary__meta { margin: 0 0 1rem 0; color: var(--muted, #555); }
      .coverage-summary__table { width: 100%; border-collapse: collapse; font-size: .95rem; }
      .coverage-summary__table th, .coverage-summary__table td { padding: .5rem .65rem; border: 1px solid var(--border, #e2e2e2); text-align: left; }
      .coverage-summary__table th { background: rgba(0,0,0,0.04); font-weight: 600; }
      .coverage-summary__empty { margin: 0; color: var(--muted, #666); }
    `;
    (document.head || document.body || document.documentElement).appendChild(style);
  }

  function renderCoverageTable(summary) {
    const container = ensureCoverageContainer();
    if (!container) return;
    injectCoverageStyles();
    container.innerHTML = '';

    const heading = document.createElement('h2');
    heading.textContent = 'Coverage summary';
    container.appendChild(heading);

    const meta = document.createElement('p');
    meta.className = 'coverage-summary__meta';
    const total = Number(summary && summary.total_profiles);
    meta.textContent = Number.isFinite(total)
      ? `Total speaker profiles: ${total}`
      : 'Coverage summary by speaker profile attributes.';
    container.appendChild(meta);

    const coverage = Array.isArray(summary && summary.coverage) ? summary.coverage : [];
    if (!coverage.length) {
      const empty = document.createElement('p');
      empty.className = 'coverage-summary__empty';
      empty.textContent = 'No coverage information available.';
      container.appendChild(empty);
      return;
    }

    const table = document.createElement('table');
    table.className = 'coverage-summary__table';

    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    ['Dialect family', 'Dialect subregion', 'Gender', 'Age band', 'Count'].forEach((label) => {
      const cell = document.createElement('th');
      cell.textContent = label;
      headerRow.appendChild(cell);
    });
    thead.appendChild(headerRow);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');
    coverage.forEach((entry) => {
      const row = document.createElement('tr');
      const cells = [
        formatCoverageLabel(entry.dialect_family),
        formatCoverageLabel(entry.dialect_subregion),
        formatCoverageLabel(entry.gender),
        formatCoverageLabel(entry.age_band),
        Number(entry.count) || 0,
      ];
      cells.forEach((value) => {
        const cell = document.createElement('td');
        cell.textContent = value;
        row.appendChild(cell);
      });
      tbody.appendChild(row);
    });
    table.appendChild(tbody);
    container.appendChild(table);
  }

  function fetchCoverageSummary() {
    if (typeof fetch !== 'function') {
      return Promise.resolve(null);
    }
    return fetch('coverage_summary.json', { cache: 'no-store' })
      .then((response) => {
        if (!response.ok) return null;
        return response.json().catch(() => null);
      })
      .catch(() => null);
  }

  if (typeof window !== 'undefined') {
    window.addEventListener('DOMContentLoaded', () => {
      fetchCoverageSummary().then((summary) => {
        if (summary) {
          renderCoverageTable(summary);
        } else {
          const container = ensureCoverageContainer();
          if (container) {
            injectCoverageStyles();
            container.innerHTML = '';
            const heading = document.createElement('h2');
            heading.textContent = 'Coverage summary';
            container.appendChild(heading);
            const empty = document.createElement('p');
            empty.className = 'coverage-summary__empty';
            empty.textContent = 'Coverage summary not available.';
            container.appendChild(empty);
          }
        }
      });
    });
  }

  // --- Public API ------------------------------------------------------------
  const api = {
    recordAnnotation,
    computeAlpha,
    computeIRRSummary,
    saveIRRSummary,
    // Legacy/diagnostic helpers
    _loadRecords: () => clone(ensureRecords()),
    _saveRecords: (records) => persistRecords(records),
    _internal: {
      normalizeRecords,
      ensureRecords,
      sanitizeMetrics,
    },
  };

  if (typeof module !== "undefined" && module.exports) {
    module.exports = api;
  } else {
    global.IRR = api;
  }
})(typeof window !== "undefined" ? window : globalThis);
